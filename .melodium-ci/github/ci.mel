use root/github/actions/third/actions/cache/ref_v4::cache
use root/github/actions/third/actions/checkout/ref_v5::checkout
use root/github/actions/third/david_anson/markdownlint_cli2_action/ref_v20::markdownlintCli2Action
use root/github/actions/third/dtolnay/rust_toolchain/ref_nightly::rustToolchain as RefNightlyrustToolchain
use root/github/actions/third/dtolnay/rust_toolchain/ref_stable::rustToolchain as RefStablerustToolchain
use root/github/actions/third/peter_evans/create_pull_request/ref_v7::createPullRequest
use root/github/actions/third/swatinem/rust_cache/ref_v2::rustCache
use root/github/actions/third/taiki_e/install_action/ref_cargo_hack::installAction as RefCargoHackinstallAction
use root/github/actions/third/taiki_e/install_action/ref_v2::installAction as RefV2installAction
use root/github/actions/third/taiki_e/setup_cross_toolchain_action/ref_v1::setupCrossToolchainAction
use cicd/services/github::githubJobResult
use cicd/services/github::includeNeeds
use cicd/services/github::prepareContexts
use cicd/services/github::runAction
use javascript::JavaScriptEngine
use json/value::|null
use json::Json
use log/logger::Logger
use std/data/string_map::StringMap
use std/data/string_map::|entry
use std/data/string_map::|map
use std/flow/concentrate::Concentrator
use std/flow/concentrate::concentrateBlock
use std/flow/concentrate::concentrated
use std/flow::trigger
use std/ops/option::|wrap
use std/text/compose::|format

treatment buildTestAyaAll[logger: Logger](
        var github_contexts: string
)
  input trigger: Block<void>
  output finished: Block<void>
  model finishConcentrator: Concentrator()
{
    aarch64: buildTestAya[logger=logger](target_arch="aarch64-unknown-linux-gnu", github_contexts=github_contexts)
    armv7: buildTestAya[logger=logger](target_arch="armv7-unknown-linux-gnueabi", github_contexts=github_contexts)
    powerpc64le: buildTestAya[logger=logger](target_arch="powerpc64le-unknown-linux-gnu", github_contexts=github_contexts)
    riscv64gc: buildTestAya[logger=logger](target_arch="riscv64gc-unknown-linux-gnu", github_contexts=github_contexts)
    s390x: buildTestAya[logger=logger](target_arch="s390x-unknown-linux-gnu", github_contexts=github_contexts)
    x86_64: buildTestAya[logger=logger](target_arch="x86_64-unknown-linux-gnu", github_contexts=github_contexts)

    aarch64Finished: concentrateBlock<void>[concentrator = finishConcentrator]()
    armv7Finished: concentrateBlock<void>[concentrator = finishConcentrator]()
    powerpc64leFinished: concentrateBlock<void>[concentrator = finishConcentrator]()
    riscv64gcFinished: concentrateBlock<void>[concentrator = finishConcentrator]()
    s390xFinished: concentrateBlock<void>[concentrator = finishConcentrator]()
    x86_64Finished: concentrateBlock<void>[concentrator = finishConcentrator]()


    Self.trigger -> aarch64.trigger,finished -> aarch64Finished.data
    Self.trigger -> armv7.trigger,finished -> armv7Finished.data
    Self.trigger -> powerpc64le.trigger,finished -> powerpc64leFinished.data
    Self.trigger -> riscv64gc.trigger,finished -> riscv64gcFinished.data
    Self.trigger -> s390x.trigger,finished -> s390xFinished.data
    Self.trigger -> x86_64.trigger,finished -> x86_64Finished.data

    finish: concentrated<void>[concentrator = finishConcentrator]()
    finishTrigger: trigger<void>()

    Self.trigger -> finish.trigger,data -> finishTrigger.stream,end -> Self.finished
}

#[job(buildTestAya)]
#[generated(true)]
treatment buildTestAya[logger: Logger](
        var github_contexts: string,
        var target_arch: string
)
  input trigger: Block<void>
  output finished: Block<void>
  output result: Block<Json>
  model contexts: JavaScriptEngine()
{
    
    
    jobResult: githubJobResult[contexts = contexts](
        local_context = |null(
        
        ),
        name = "buildTestAya",
        outputs = |map(
        []
        )
    )
    prepareContexts[contexts = contexts](
        github_contexts = github_contexts
    )
    step0: checkout[contexts = contexts, logger = logger](
        path = |format("/tmp/{arch}", |entry("arch", target_arch))
    )
    step1: RefStablerustToolchain[contexts = contexts, logger = logger](
        targets = target_arch
    )
    step2: rustCache[contexts = contexts, logger = logger](
        workspaces = |format("/tmp/{arch}", |entry("arch", target_arch))
    )
    step3: RefCargoHackinstallAction[contexts = contexts, logger = logger]()
    step4: setupCrossToolchainAction[contexts = contexts, logger = logger](
        target = target_arch
    )
    build: runAction[contexts = contexts, logger = logger](
        working_directory = |wrap<string>(|format("/tmp/{arch}", |entry("arch", target_arch))),
        commands = ${
set -euxo pipefail
cargo hack build --all-targets --feature-powerset \
  --exclude aya-ebpf \
  --exclude aya-ebpf-bindings \
  --exclude aya-log-ebpf \
  --exclude integration-ebpf \
  --exclude xtask \
  --workspace
},
        display_name = "Build",
        name = "build"
    )
    test: runAction[contexts = contexts, logger = logger](
        working_directory = |wrap<string>(|format("/tmp/{arch}", |entry("arch", target_arch))),
        commands = ${set -euxo pipefail
cargo hack test --all-targets --feature-powerset \
  --exclude aya-ebpf \
  --exclude aya-ebpf-bindings \
  --exclude aya-log-ebpf \
  --exclude integration-ebpf \
  --exclude integration-test \
  --exclude xtask \
  --workspace
},
        display_name = "Test",
        env = |wrap<StringMap>(
        |map(
            [|entry(
                    "RUST_BACKTRACE",
                    "full"
                    )]
            )
        ),
        name = "test"
    )
    doctests: runAction[contexts = contexts, logger = logger](
        working_directory = |wrap<string>(|format("/tmp/{arch}", |entry("arch", target_arch))),
        commands = ${
set -euxo pipefail
cargo hack test --doc --feature-powerset \
  --exclude aya-ebpf \
  --exclude aya-ebpf-bindings \
  --exclude aya-log-ebpf \
  --exclude init \
  --exclude integration-ebpf \
  --exclude integration-test \
  --exclude xtask \
  --workspace
},
        display_name = "Doctests",
        env = |wrap<StringMap>(
        |map(
            [|entry(
                    "RUST_BACKTRACE",
                    "full"
                    )]
            )
        ),
        name = "doctests"
    )

    Self.trigger -> prepareContexts.trigger
    prepareContexts.ready -> step0.trigger
    step0.continue -> step1.trigger
    step1.continue -> step2.trigger
    step2.continue -> step3.trigger
    step3.continue -> step4.trigger
    step4.continue -> build.trigger
    build.continue -> test.trigger
    test.continue -> doctests.trigger
    doctests.continue -> jobResult.trigger_release
    jobResult.result -> Self.result
    jobResult.finished -> Self.finished
    jobResult.finished -> step0.post_trigger
    jobResult.finished -> step2.post_trigger
}

/*
#[generated(true)]
#[job(buildTestAyaEbpf)]
treatment buildTestAyaEbpf[logger: Logger](
        var github_contexts: string
)
  input trigger: Block<void>
  output finished: Block<void>
  output result: Block<Json>
  model contexts: JavaScriptEngine()
{
    build: runAction[contexts = contexts, logger = logger](
        commands = ${{{set -euxo pipefail
cargo +nightly hack build \
  --target ${{ matrix.target }} \
  -Z build-std=core \
  --package aya-ebpf \
  --package aya-log-ebpf \
  --feature-powerset
}}},
        display_name = "Build",
        env = |wrap<StringMap>(
        |map(
            [|entry(
                    "CARGO_CFG_BPF_TARGET_ARCH",
                    "${{ matrix.bpf_target_arch }}"
                    )]
            )
        ),
        name = "build"
    )
    jobResult: githubJobResult[contexts = contexts](
        local_context = |null(
        
        ),
        name = "buildTestAyaEbpf",
        outputs = |map(
        []
        )
    )
    prepareContexts[contexts = contexts](
        github_contexts = github_contexts
    )
    step0: checkout[contexts = contexts, logger = logger]()
    step1: RefNightlyrustToolchain[contexts = contexts, logger = logger](
        components = "rust-src"
    )
    step2: RefStablerustToolchain[contexts = contexts, logger = logger]()
    step3: rustCache[contexts = contexts, logger = logger]()
    step4: runAction[contexts = contexts, logger = logger](
        commands = "cargo install --git https://github.com/aya-rs/bpf-linker.git bpf-linker --features llvm-21",
        name = "step4"
    )
    step5: RefCargoHackinstallAction[contexts = contexts, logger = logger]()
    test: runAction[contexts = contexts, logger = logger](
        commands = ${set -euxo pipefail
cargo hack test \
  --doc \
  --package aya-ebpf \
  --package aya-log-ebpf \
  --feature-powerset
},
        display_name = "Test",
        env = |wrap<StringMap>(
        |map(
            [|entry(
                    "RUST_BACKTRACE",
                    "full"
                    ),
                |entry(
                    "CARGO_CFG_BPF_TARGET_ARCH",
                    "${{ matrix.bpf_target_arch }}"
                    )]
            )
        ),
        name = "test"
    )

    Self.trigger -> prepareContexts.trigger
    prepareContexts.ready -> step0.trigger
    step0.continue -> step1.trigger
    step1.continue -> step2.trigger
    step2.continue -> step3.trigger
    step3.continue -> step4.trigger
    step4.continue -> step5.trigger
    step5.continue -> build.trigger
    build.continue -> test.trigger
    test.continue -> jobResult.trigger_release
    jobResult.result -> Self.result
    jobResult.finished -> Self.finished
    jobResult.finished -> step0.post_trigger
    jobResult.finished -> step3.post_trigger
}

#[generated(true)]
#[job(buildWorkflowComplete)]
treatment buildWorkflowComplete[logger: Logger](
        var github_contexts: string
)
  #[job(build-test-aya)]
  input need_build_test_aya: Block<Json>
  #[job(build-test-aya-ebpf)]
  input need_build_test_aya_ebpf: Block<Json>
  #[job(lint)]
  input need_lint: Block<Json>
  #[job(run-integration-test)]
  input need_run_integration_test: Block<Json>
  input trigger: Block<void>
  output finished: Block<void>
  output result: Block<Json>
  model contexts: JavaScriptEngine()
  model readinessConcentrator: Concentrator()
{
    includeNeedsBuildTestAya: includeNeeds[contexts = contexts](
        from = "build-test-aya"
    )
    includeNeedsBuildTestAyaEbpf: includeNeeds[contexts = contexts](
        from = "build-test-aya-ebpf"
    )
    includeNeedsBuildTestAyaEbpfReady: concentrateBlock<void>[concentrator = readinessConcentrator]()
    includeNeedsBuildTestAyaReady: concentrateBlock<void>[concentrator = readinessConcentrator]()
    includeNeedsLint: includeNeeds[contexts = contexts](
        from = "lint"
    )
    includeNeedsLintReady: concentrateBlock<void>[concentrator = readinessConcentrator]()
    includeNeedsRunIntegrationTest: includeNeeds[contexts = contexts](
        from = "run-integration-test"
    )
    includeNeedsRunIntegrationTestReady: concentrateBlock<void>[concentrator = readinessConcentrator]()
    jobResult: githubJobResult[contexts = contexts](
        local_context = |null(
        
        ),
        name = "buildWorkflowComplete",
        outputs = |map(
        []
        )
    )
    prepareContexts[contexts = contexts](
        github_contexts = github_contexts
    )
    readiness: concentrated<void>[concentrator = readinessConcentrator]()
    readinessTrigger: trigger<void>()
    step0: runAction[contexts = contexts, logger = logger](
        commands = "echo 'Build Complete'",
        name = "step0"
    )

    Self.trigger -> prepareContexts.trigger
    Self.need_lint -> includeNeedsLint.needs
    prepareContexts.ready -> includeNeedsLint.trigger
    includeNeedsLint.ready -> includeNeedsLintReady.data
    Self.need_build_test_aya -> includeNeedsBuildTestAya.needs
    prepareContexts.ready -> includeNeedsBuildTestAya.trigger
    includeNeedsBuildTestAya.ready -> includeNeedsBuildTestAyaReady.data
    Self.need_build_test_aya_ebpf -> includeNeedsBuildTestAyaEbpf.needs
    prepareContexts.ready -> includeNeedsBuildTestAyaEbpf.trigger
    includeNeedsBuildTestAyaEbpf.ready -> includeNeedsBuildTestAyaEbpfReady.data
    Self.need_run_integration_test -> includeNeedsRunIntegrationTest.needs
    prepareContexts.ready -> includeNeedsRunIntegrationTest.trigger
    includeNeedsRunIntegrationTest.ready -> includeNeedsRunIntegrationTestReady.data
    Self.trigger -> readiness.trigger
    readiness.data -> readinessTrigger.stream
    readinessTrigger.last -> step0.trigger
    step0.continue -> jobResult.trigger_release
    jobResult.result -> Self.result
    jobResult.finished -> Self.finished
}

#[generated(true)]
#[job(lint)]
treatment lint[logger: Logger](
        var github_contexts: string
)
  input trigger: Block<void>
  output finished: Block<void>
  output result: Block<Json>
  model contexts: JavaScriptEngine()
{
    jobResult: githubJobResult[contexts = contexts](
        local_context = |null(
        
        ),
        name = "lint",
        outputs = |map(
        []
        )
    )
    prepareContexts[contexts = contexts](
        github_contexts = github_contexts
    )
    runMiri: runAction[contexts = contexts, logger = logger](
        commands = ${set -euxo pipefail
cargo +nightly hack miri test --all-targets --feature-powerset \
  --exclude aya-ebpf \
  --exclude aya-ebpf-bindings \
  --exclude aya-log-ebpf \
  --exclude integration-ebpf \
  --exclude integration-test \
  --workspace
},
        display_name = "Run miri",
        name = "runMiri"
    )
    step0: checkout[contexts = contexts, logger = logger]()
    step1: RefNightlyrustToolchain[contexts = contexts, logger = logger](
        components = "clippy,miri,rustfmt,rust-src"
    )
    step10: runAction[contexts = contexts, logger = logger](
        commands = "cargo xtask public-api",
        if = "${{ !(github.event_name == 'schedule' && github.repository == 'aya-rs/aya') }}",
        name = "step10"
    )
    step11: runAction[contexts = contexts, logger = logger](
        commands = "cargo xtask public-api --bless",
        if = "${{ (github.event_name == 'schedule' && github.repository == 'aya-rs/aya') }}",
        name = "step11"
    )
    step12: createPullRequest[contexts = contexts, logger = logger](
        body = ${**Automated changes**
},
        branch = "create-pull-request/public-api",
        commit_message = "public-api: regenerate",
        title = "public-api: regenerate",
        token = "${{ secrets.CRABBY_GITHUB_TOKEN }}"
    )
    step2: RefStablerustToolchain[contexts = contexts, logger = logger]()
    step3: rustCache[contexts = contexts, logger = logger]()
    step4: RefV2installAction[contexts = contexts, logger = logger](
        tool = "cargo-hack,taplo-cli"
    )
    step5: runAction[contexts = contexts, logger = logger](
        commands = "git ls-files -- '*.c' '*.h' | xargs clang-format --dry-run --Werror",
        name = "step5"
    )
    step6: markdownlintCli2Action[contexts = contexts, logger = logger]()
    step7: runAction[contexts = contexts, logger = logger](
        commands = "taplo fmt --check",
        name = "step7"
    )
    step8: runAction[contexts = contexts, logger = logger](
        commands = "cargo +nightly fmt --all -- --check",
        name = "step8"
    )
    step9: runAction[contexts = contexts, logger = logger](
        commands = "./clippy.sh",
        name = "step9"
    )

    Self.trigger -> prepareContexts.trigger
    prepareContexts.ready -> step0.trigger
    step0.continue -> step1.trigger
    step1.continue -> step2.trigger
    step2.continue -> step3.trigger
    step3.continue -> step4.trigger
    step4.continue -> step5.trigger
    step5.continue -> step6.trigger
    step6.continue -> step7.trigger
    step7.continue -> step8.trigger
    step8.continue -> step9.trigger
    step9.continue -> step10.trigger
    step10.continue -> step11.trigger
    step11.continue -> step12.trigger
    step12.continue -> runMiri.trigger
    runMiri.continue -> jobResult.trigger_release
    jobResult.result -> Self.result
    jobResult.finished -> Self.finished
    jobResult.finished -> step0.post_trigger
    jobResult.finished -> step3.post_trigger
}

#[generated(true)]
#[job(runIntegrationTest)]
treatment runIntegrationTest[logger: Logger](
        var github_contexts: string
)
  input trigger: Block<void>
  output finished: Block<void>
  output result: Block<Json>
  model contexts: JavaScriptEngine()
{
    cleanupStaleKernelsAndModules: runAction[contexts = contexts, logger = logger](
        commands = ${set -euxo pipefail
rm -rf test/.tmp/boot test/.tmp/lib
},
        display_name = "Cleanup stale kernels and modules",
        name = "cleanupStaleKernelsAndModules"
    )
    downloadDebianKernels: runAction[contexts = contexts, logger = logger](
        commands = ".github/scripts/download_kernel_images.sh test/.tmp/debian-kernels/arm64 arm64 6.1 6.12",
        display_name = "Download debian kernels",
        if = "runner.arch == 'ARM64'",
        name = "downloadDebianKernels"
    )
    downloadDebianKernels_10: runAction[contexts = contexts, logger = logger](
        commands = ".github/scripts/download_kernel_images.sh test/.tmp/debian-kernels/amd64 amd64 6.1 6.12",
        display_name = "Download debian kernels",
        if = "runner.arch == 'X64'",
        name = "downloadDebianKernels_10"
    )
    extractDebianKernels: runAction[contexts = contexts, logger = logger](
        commands = ${{set -euxo pipefail
# Modules are required since not all parts of the kernel we want to
# test are built-in.
find test/.tmp -name '*.deb' -print0 | xargs -t -0 -I {} \
  sh -c "dpkg --fsys-tarfile {} | tar -C test/.tmp \
    --wildcards --extract '** /boot/ *' '** /modules/ *' --file -"
}},
        display_name = "Extract debian kernels",
        name = "extractDebianKernels"
    )
    installLibLlvm: runAction[contexts = contexts, logger = logger](
        commands = ${{{set -euxo pipefail
# Get the partial SHA from Rust nightly.
rustc_sha=$(rustc +nightly --version | grep -oE '[a-f0-9]{7,40}')
# Get the full SHA from GitHub.
rustc_sha=$(curl -sfSL https://api.github.com/repos/rust-lang/rust/commits/$rustc_sha \
  --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' \
  --header 'content-type: application/json' \
  | jq -r '.sha')
mkdir -p /tmp/rustc-llvm
curl -sfSL https://ci-artifacts.rust-lang.org/rustc-builds/$rustc_sha/rust-dev-nightly-${{ matrix.target }}.tar.xz | \
  tar -xJ --strip-components 2 -C /tmp/rustc-llvm
echo /tmp/rustc-llvm/bin >> $GITHUB_PATH
}}},
        display_name = "Install libLLVM",
        name = "installLibLlvm"
    )
    installPrerequisites: runAction[contexts = contexts, logger = logger](
        commands = ${{set -euxo pipefail
sudo apt update
sudo apt -y install lynx qemu-system-{arm,x86} musl-tools
echo /usr/lib/llvm-15/bin >> $GITHUB_PATH
}},
        display_name = "Install prerequisites",
        if = "runner.os == 'Linux'",
        name = "installPrerequisites"
    )
    installPrerequisites_2: runAction[contexts = contexts, logger = logger](
        commands = ${{set -euxo pipefail
brew update
# https://github.com/actions/setup-python/issues/577
find /usr/local/bin -type l -exec sh -c 'readlink -f "$1" \
| grep -q ^/Library/Frameworks/Python.framework/Versions/' _ {} \; -exec rm -v {} \;
brew install --formula curl dpkg gnu-tar llvm lynx pkg-config qemu
echo $(brew --prefix curl)/bin >> $GITHUB_PATH
echo $(brew --prefix gnu-tar)/libexec/gnubin >> $GITHUB_PATH
echo $(brew --prefix llvm)/bin >> $GITHUB_PATH
brew install filosottile/musl-cross/musl-cross
ln -s "$(brew --prefix musl-cross)/bin/x86_64-linux-musl-gcc" /usr/local/bin/musl-gcc
}},
        display_name = "Install prerequisites",
        if = "runner.os == 'macOS'",
        name = "installPrerequisites_2"
    )
    jobResult: githubJobResult[contexts = contexts](
        local_context = |null(
        
        ),
        name = "runIntegrationTest",
        outputs = |map(
        []
        )
    )
    prepareContexts[contexts = contexts](
        github_contexts = github_contexts
    )
    runLocalIntegrationTests: runAction[contexts = contexts, logger = logger](
        commands = "cargo xtask integration-test local",
        display_name = "Run local integration tests",
        if = "runner.os == 'Linux'",
        name = "runLocalIntegrationTests"
    )
    runVirtualizedIntegrationTests: runAction[contexts = contexts, logger = logger](
        commands = ${{{set -euxo pipefail
.github/scripts/find_kernels.py | xargs -t -0 \
cargo xtask integration-test vm --cache-dir test/.tmp \
  --github-api-token ${{ secrets.GITHUB_TOKEN }} \
}}},
        display_name = "Run virtualized integration tests",
        if = "runner.os == 'Linux'",
        name = "runVirtualizedIntegrationTests"
    )
    runVirtualizedIntegrationTests_15: runAction[contexts = contexts, logger = logger](
        commands = ${{{set -euxo pipefail
.github/scripts/find_kernels.py | xargs -t -0 \
cargo xtask integration-test vm --cache-dir test/.tmp \
  --github-api-token ${{ secrets.GITHUB_TOKEN }} \
}}},
        display_name = "Run virtualized integration tests",
        env = |wrap<StringMap>(
        |map(
            [|entry(
                    "CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER",
                    "x86_64-linux-musl-gcc"
                    )]
            )
        ),
        if = "runner.os == 'macOS'",
        name = "runVirtualizedIntegrationTests_15"
    )
    step0: checkout[contexts = contexts, logger = logger](
        submodules = "recursive"
    )
    step3: RefNightlyrustToolchain[contexts = contexts, logger = logger](
        components = "rust-src"
    )
    step4: RefStablerustToolchain[contexts = contexts, logger = logger](
        targets = "aarch64-unknown-linux-musl,x86_64-unknown-linux-musl"
    )
    step5: rustCache[contexts = contexts, logger = logger]()
    step7: runAction[contexts = contexts, logger = logger](
        commands = "cargo install --git https://github.com/aya-rs/bpf-linker.git bpf-linker --no-default-features --features llvm-21 --force",
        name = "step7"
    )
    step8: cache[contexts = contexts, logger = logger](
        key = "${{ runner.arch }}-${{ runner.os }}-test-cache",
        path = "test/.tmp"
    )

    Self.trigger -> prepareContexts.trigger
    prepareContexts.ready -> step0.trigger
    step0.continue -> installPrerequisites.trigger
    installPrerequisites.continue -> installPrerequisites_2.trigger
    installPrerequisites_2.continue -> step3.trigger
    step3.continue -> step4.trigger
    step4.continue -> step5.trigger
    step5.continue -> installLibLlvm.trigger
    installLibLlvm.continue -> step7.trigger
    step7.continue -> step8.trigger
    step8.continue -> downloadDebianKernels.trigger
    downloadDebianKernels.continue -> downloadDebianKernels_10.trigger
    downloadDebianKernels_10.continue -> cleanupStaleKernelsAndModules.trigger
    cleanupStaleKernelsAndModules.continue -> extractDebianKernels.trigger
    extractDebianKernels.continue -> runLocalIntegrationTests.trigger
    runLocalIntegrationTests.continue -> runVirtualizedIntegrationTests.trigger
    runVirtualizedIntegrationTests.continue -> runVirtualizedIntegrationTests_15.trigger
    runVirtualizedIntegrationTests_15.continue -> jobResult.trigger_release
    jobResult.result -> Self.result
    jobResult.finished -> Self.finished
    jobResult.finished -> step0.post_trigger
    jobResult.finished -> step5.post_trigger
    jobResult.finished -> step8.post_trigger
}

*/