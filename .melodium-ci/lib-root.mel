use cicd/steps::stepOn
use cicd/logging::manageLogs
use cicd/runners::CicdDispatchEngine
use cicd/runners::CicdRunnerEngine
use cicd/runners::setupRunner
use cicd/runners::stopRunner
use log/logger::Logger
use process/command::|raw_commands
use process/environment::Environment
use process/environment::|environment
use std/data/string_map::|entry
use std/data/string_map::|map
use std/engine/util::startup
use std/flow::waitBlock
use std/ops/option::|wrap
use std/text/compose::|format
use work/resources::|container
use work/resources/arch::|amd64

treatment buildTestAya()
  model logger: Logger()
  model dispatcher: CicdDispatchEngine(location="compose", api_token="")
  model runner: CicdRunnerEngine()
{
    startup()
    manageLogs[logger=logger](output_directory="logs/")
    setupRunner[logger=logger, dispatcher=dispatcher, runner=runner](
        name="buildTestAya",
        cpu=100,
        memory=150,
        storage=800,
        containers=[
            |container("aarch64", 6000, 1000, 8000, |amd64(), [], "ghcr.io/cross-rs/aarch64-unknown-linux-gnu" /*"rust:1.90-bookworm"*/, _)
        ]
    )

    buildTestAyaForArch[logger=logger, runner=runner](
        short="aarch64",
        arch="aarch64-unknown-linux-gnu",
        repository_clone_ref="melodium_ci",
        repository_clone_url="https://github.com/qvignaud/aya.git"
    )

    stopRunner[runner=runner]()

    startup.trigger -> setupRunner.trigger,ready -> buildTestAyaForArch.trigger,finished -> manageLogs.stop
    buildTestAyaForArch.finished -> stopRunner.trigger
}

treatment buildTestAyaForArch[logger: Logger, runner: CicdRunnerEngine](short: string, arch: string, repository_clone_ref: string, repository_clone_url: string)
  input trigger: Block<void>
  output finished: Block<void>
{
    prepare: stepOn[logger=logger, runner=runner](
        name = |format("prepare_{short}", |entry("short", short)),
        executor_name = |wrap<string>(short),
        commands = |raw_commands([
            //|format("rustup target add {arch}", |entry("arch", arch)),
            "cross binstall cargo-hack" //,
            //${bash -c "curl https://raw.githubusercontent.com/taiki-e/install-action/refs/heads/cargo-hack/main.sh | bash -"},
            //${bash -c "curl https://raw.githubusercontent.com/taiki-e/setup-cross-toolchain-action/refs/tags/v1/main.sh | bash -"}
        ]),
        environment = |wrap<Environment>(
            |environment(
                |map([
                    |entry("INPUT_TOOL", "cargo-hack"),
                    |entry("INPUT_TARGET", arch)
                ]),
                _, // working_directory
                false, // expand_variables
                false // clear_env
            )
        )
    )

    checkout: stepOn[logger=logger, runner=runner](
        name = |format("checkout_{short}", |entry("short", short)),
        executor_name = |wrap<string>(short),
        commands = |raw_commands([
            "git config --global url.https://.insteadOf  git://",
            |format("git clone --branch {repository_clone_ref} --depth 1 {repository_clone_url} /root/aya",
                |map([
                    |entry("repository_clone_ref", repository_clone_ref),
                    |entry("repository_clone_url", repository_clone_url)
                ])
            )
        ])
    )

    ready: waitBlock<void>()

    build: stepOn[logger=logger, runner=runner](
        name = |format("build_{short}", |entry("short", short)),
        executor_name = |wrap<string>(short),
        commands = |raw_commands([
            // Build
            "cross hack build --all-targets --feature-powerset --exclude aya-ebpf --exclude aya-ebpf-bindings --exclude aya-log-ebpf --exclude integration-ebpf --exclude xtask --workspace",
            // Test
            "cross hack test --all-targets --feature-powerset --exclude aya-ebpf --exclude aya-ebpf-bindings --exclude aya-log-ebpf --exclude integration-ebpf --exclude integration-test --exclude xtask --workspace",
            // Doc
            "cross hack test --doc --feature-powerset --exclude aya-ebpf --exclude aya-ebpf-bindings --exclude aya-log-ebpf --exclude integration-ebpf --exclude integration-test --exclude xtask --workspace"
        ]),
        environment = |wrap<Environment>(
            |environment(
                |map([
                    |entry("RUST_BACKTRACE", "full")/*,
                    |entry("CARGO_BUILD_TARGET", arch)*/
                ]),
                "/root/aya", // working_directory
                false, // expand_variables
                false // clear_env
            )
        )
    )

    Self.trigger -> prepare.trigger,completed --> ready.a,awaited -> build.trigger,finished -> Self.finished
    Self.trigger -> checkout.trigger,completed -> ready.b
}

/*
treatment buildTestAya()
{

}

treatment buildTestAyaForArch[logger: Logger](arch: string, short_arch: string)
  trigger: Block<void>
{
    build: localStep[logger=logger](
        name = |format("build_{short_arch}", |entry("short_arch", short_arch)),
        description = |format("Build tests for Aya on {arch}", |entry("arch", arch)),
        commands = |raw_commands([
            // Build
            "cargo hack build --all-targets --feature-powerset --exclude aya-ebpf --exclude aya-ebpf-bindings --exclude aya-log-ebpf --exclude integration-ebpf --exclude xtask --workspace",
            // Test
            "cargo hack test --all-targets --feature-powerset --exclude aya-ebpf --exclude aya-ebpf-bindings --exclude aya-log-ebpf --exclude integration-ebpf --exclude integration-test --exclude xtask --workspace",
            // Doc
            "cargo hack test --doc --feature-powerset --exclude aya-ebpf --exclude aya-ebpf-bindings --exclude aya-log-ebpf --exclude integration-ebpf --exclude integration-test --exclude xtask --workspace"
        ]),
        variables = |wrap<StringMap>(|map([
            |entry("RUST_BACKTRACE", "full"),
            |entry("CARGO_BUILD_TARGET", arch)
        ]))
    )
}*/